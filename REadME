/*
use cache.cpp for getting print after read and write and cache_no_print.cpp for no print statements it will only print hit rate as of no print statements it will proccess more requests.
--------------------------------------------------------------------------------------------------------------------------------------------------
Set-Associative Cache:
Have Implemented a cache having given specifications as follows
Cache Size: 32 KB, Block Size: 64 Bytes, Associativity: 8-way, Address Size: 40 bits, Word Size: 4 Bytes ,Random Replacement, Write through(Hit), Write No-allocate(miss), Address Size=40 bits

Implementation:
Generated a normal distribution address with help of a function and making mean and standard deviation high to get a cluster of addresses
Then after generating addresses , checked it as less than (2^40)-1 and then removed the last two bits as memory is in multiples of 4.and for every three requests one will be write and remaining two are read.
After that the address is being sent to cache and in cache it is divided into three parts as offset,tag,index  and wordoffset.
Now at corresponding index , the whole set is being checked if the needed tag is present and then if the state is valid or not then 
if present and state is valid it is a hit else its a miss.
For Hit if its read request just take the data from cache at that location and then returning and if it's a write request 
then using the write through (write-strategy) as changing the data in cache and sending a memory request to change the data.
For Miss if it's a read request then load the data from memory by sending a memory request after that the data is returned and 
this Block placement and replacement is done using Randomreplacementeviction generally chooses any of the block in the set.
If the invalid are present then first choose randomly from that invalid and if all are valid then take from them.
firstly we change the tag of that block an d thn its state to misspending and then after memory response change the state to valid.
If its a write request then using write no-allocate policy as the block is not requested to bring into cache instead we are 
sending the request directly to memory to change or required modification.


Classes Implementation:
1. CacheBlock
Represents a cache block with:
State: Indicates whether the block is Invalid, Valid, or MissPending.
Tag: Identifies the block.
Data: Stores data in the block, partitioned based on word size.
2. CacheSet
Represents a set in the cache containing multiple CacheBlock objects:
findTag: Searches for a block by tag within the set.
getRandomEvictionIndex: Chooses a random block index for eviction if all blocks in the set are valid.
3. Cache
Manages the entire cache with:
Cache Details: Calculates cache structure, such as the number of sets and bit allocations.
cache check and process: Processes each read (R) or write (W) request, updating the cache and checking for hits or misses.
printHitRate: Outputs the total number of accesses, hits, misses, and hit/miss rates.


-------------------------------------------------------------------------------------------------------------------------------------------------
For implementing lru policy and write back policy:
taken an  extra parameter for the block as accessindex like every time accessing we are increasing it and to evict we will select the least recentlu used index from the existing and also 
for write-back we are making a new state called dirty state in removing while evicting we will get to know that it want to be modified and to send mem request
Below is the implementation:
#include <bits/stdc++.h>
using namespace std;
using namespace std::chrono;

// specifications
#define CACHE_SIZE 32768 
#define BLOCK_SIZE 64 
#define ASSOCIATIVITY 8 
#define ADDRESS_SIZE 40 
#define WORD_SIZE 4 

enum State {
    Invalid, Valid, MissPending, Dirty
};

class CacheBlock {
public:
    State state;
    int tag;
    int accessCounter;  
    vector<string> data;
    CacheBlock() : state(Invalid), tag(0), accessCounter(0) {
        data.resize(BLOCK_SIZE / WORD_SIZE, "");
    }
};

class CacheSet {
public:
    vector<CacheBlock> blocks;

    CacheSet() {
        blocks.resize(ASSOCIATIVITY);
    }

    int findTag(int tag) {
        for (int i = 0; i < ASSOCIATIVITY; ++i) {
            if (blocks[i].state != Invalid && blocks[i].tag == tag)
                return i;
        }
        return -1;
    }

    int getLRUEvictionIndex() {
        int lruIndex = 0;
        for (int i = 1; i < ASSOCIATIVITY; ++i) {
            if (blocks[i].accessCounter < blocks[lruIndex].accessCounter) {
                lruIndex = i;
            }
        }
        return lruIndex;
    }
};

class Cache {
public:
    int cacheSize;
    int blockSize;
    int associativity;
    int numSets;
    int indexBits;
    int blockOffsetBits;
    int tagBits;
    int totalAccesses;
    int totalHits;
    vector<CacheSet> cacheSets;
    int accessCounter;

    Cache() {
        cacheSize = CACHE_SIZE;
        blockSize = BLOCK_SIZE;
        associativity = ASSOCIATIVITY;
        numSets = cacheSize / (blockSize * associativity);
        blockOffsetBits = log2(blockSize);
        indexBits = log2(numSets);
        tagBits = ADDRESS_SIZE - blockOffsetBits - indexBits;
        cacheSets.resize(numSets);
        totalAccesses = 0;
        totalHits = 0;
        accessCounter = 0;
    }

    void cache_details() {
        cout << "-------------------------------------------" << endl;
        cout << "       CACHE CONFIGURATION           " << endl;
        cout << "-------------------------------------------" << endl;
        cout << "Cache Type                : " << associativity << "-way Set-Associative Cache" << endl;
        cout << "Cache Size                : " << cacheSize / 1024 << " KB" << endl;
        cout << "Block Size                : " << blockSize << " Bytes" << endl;
        cout << "Associativity (No of Ways): " << associativity << " -ways" << endl;
        cout << "Number of Sets            : " << numSets << endl;
        cout << "Number of Index Bits      : " << indexBits << endl;
        cout << "Number of Block Offset Bits: " << blockOffsetBits << endl;
        cout << "Number of Tag Bits        : " << tagBits << endl;
        cout << "-------------------------------------------" << endl;
    }

    void cache_check_and_process(uint64_t address, char type, string writedata) {
        totalAccesses++;
        int offset = address & ((1 << blockOffsetBits) - 1);
        int index = (address >> blockOffsetBits) & ((1 << indexBits) - 1);
        int tag = (address >> (blockOffsetBits + indexBits)) & ((1 << tagBits) - 1);
        int wordOffsetInBlock = offset / WORD_SIZE;
        CacheSet& cacheSet = cacheSets[index];
        int blockIndex = cacheSet.findTag(tag);
        accessCounter++;

        if (blockIndex != -1 && cacheSet.blocks[blockIndex].state != Invalid) {
            CacheBlock& block = cacheSet.blocks[blockIndex];
            block.accessCounter = accessCounter;
            if (block.state == Valid || block.state == Dirty) {
                totalHits++;
                if (type == 'R') {
                    cout << "Read hit. Data: " << block.data[wordOffsetInBlock] << endl;
                } else if (type == 'W') {
                    block.data[wordOffsetInBlock] = writedata;
                    block.state = Dirty;
                    cout << "Write hit. Cache updated. Data marked as dirty." << endl;
                }
            }
        } else {
            if (type == 'R' || type == 'W') {
                cout << "Cache miss. Loading data from memory." << endl;
                int evictionIndex = -1;
                vector<int> invalidIndices;

                for (int i = 0; i < ASSOCIATIVITY; ++i) {
                    if (cacheSet.blocks[i].state == Invalid) {
                        invalidIndices.push_back(i);
                    }
                }

                if (!invalidIndices.empty()) {
                    evictionIndex = invalidIndices[rand() % invalidIndices.size()];
                } else {
                    evictionIndex = cacheSet.getLRUEvictionIndex();
                    CacheBlock& evictBlock = cacheSet.blocks[evictionIndex];
                    if (evictBlock.state == Dirty) {
                        cout << "Evicting dirty block. Writing back to memory." << endl;
                    }
                }

                CacheBlock& newBlock = cacheSet.blocks[evictionIndex];
                newBlock.state = Valid;
                newBlock.tag = tag;
                newBlock.data = vector<string>(BLOCK_SIZE / WORD_SIZE, "LoadedData");
                newBlock.accessCounter = accessCounter;

                cout << "Data loaded. Cache updated at index: " << evictionIndex << " within the set " << index << "." << endl;

                if (type == 'W') {
                    newBlock.data[wordOffsetInBlock] = writedata;
                    newBlock.state = Dirty;
                    cout << "Write-allocate: Data written to cache and marked dirty." << endl;
                }
            }
        }
    }

    void printHitRate() {
        cout << "------------------------------------" << endl;
        cout << "       CACHE HIT RATE SUMMARY      " << endl;
        cout << "------------------------------------" << endl;
        cout << "Total Accesses    : " << totalAccesses << endl;
        cout << "Total Hits        : " << totalHits << endl;
        cout << "Total Misses      : " << (totalAccesses - totalHits) << endl;
        cout << "Cache Hit Rate    : " << (100.0 * totalHits / totalAccesses) << "%" << endl;
        cout << "Cache Miss Rate   : " << (100.0 - (100.0 * totalHits / totalAccesses)) << "%" << endl;
        cout << "------------------------------------" << endl;
    }
};

uint64_t generate_address() {
    static random_device rd;
    static mt19937 generator(rd());
    uint64_t mean = 1ULL << 39;
    double stddev = static_cast<double>(1ULL << 18) / 17;
    normal_distribution<double> dist(static_cast<double>(mean), stddev);
    uint64_t address;
    do {
        address = static_cast<uint64_t>(round(dist(generator)));
        address &= ~3;
    } while (address >= (1ULL << 40));
    return address;
}

int main() {
    srand(time(NULL));
    Cache cache;
    cache.cache_details();
    auto start_time = high_resolution_clock::now();
    for (int i = 0; i < 1e8; i++) {
        uint64_t address = generate_address();
        bitset<40> binaryAddress(address);
        cout << "Generated Address: " << address << " (Binary: " << binaryAddress.to_string() << ")" << endl;
        char type = (i % 3 == 0) ? 'W' : 'R';
        cache.cache_check_and_process(address, type, "Sent_Data");

        auto end_time = high_resolution_clock::now();
        duration<double> time_duration = end_time - start_time;
        if (time_duration.count() >= 15.0) {
            cout << "Stopping after 15 seconds." << endl;
            break;
        }
    }
    cache.printHitRate();
    return 0;
}

--------------------------------------------------------------------------------------------------------------------------------
Generated Random addresses file using below code:
#include <bits/stdc++.h>
using namespace std;

uint64_t generate_address1() {
    static random_device rd;
    static mt19937 generator(rd()); 
    uint64_t mean = 1ULL << 35; 
    double stddev = static_cast<double>(1ULL << 12);
    normal_distribution<double> dist(static_cast<double>(mean), stddev);
    uint64_t address;
    do {
        address = static_cast<uint64_t>(round(dist(generator)));
        address &= ~3;
    } while (address >= (1ULL << 40));
    return address;
}
uint64_t generate_address2() {
    static random_device rd;
    static mt19937 generator(rd()); 
    uint64_t mean = 1ULL << 25; 
    double stddev = static_cast<double>(1ULL << 12);
    normal_distribution<double> dist(static_cast<double>(mean), stddev);
    uint64_t address;
    do {
        address = static_cast<uint64_t>(round(dist(generator)));
        address &= ~3;
    } while (address >= (1ULL << 40));
    return address;
}
uint64_t generate_address3() {
    static random_device rd;
    static mt19937 generator(rd()); 
    uint64_t mean = 1ULL << 20; 
    double stddev = static_cast<double>(1ULL << 12);
    normal_distribution<double> dist(static_cast<double>(mean), stddev);
    uint64_t address;
    do {
        address = static_cast<uint64_t>(round(dist(generator)));
        address &= ~3;
    } while (address >= (1ULL << 40));
    return address;
}

int main() {
    srand(time(NULL));
    ofstream outFile("addresses.txt");
    if (!outFile) {
        cout << "Error opening file!" << endl;
        return 1;
    }
    int numAddresses = 1e8;
    for (int i = 0; i < numAddresses; i++) {
        uint64_t address;
        int j=rand()%3;
        if(j==1){
             address = generate_address1();
        }
        else if(j==2){
            address = generate_address2();
        }
        else{
             address = generate_address3();
        }
        // bitset<40> binaryAddress(address);
        // outFile << binaryAddress.to_string() << endl;
        outFile << address << endl;
    }
    cout << "Addresses have been saved to 'addresses.txt'" << endl;
    outFile.close();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------
To read the address before generated and to calculate the hits we can use the below code:
#include <bits/stdc++.h>
using namespace std;
using namespace std::chrono;
#define CACHE_SIZE 32768 
#define BLOCK_SIZE 64 
#define ASSOCIATIVITY 8 
#define ADDRESS_SIZE 40 
#define WORD_SIZE 4 

enum State {
    Invalid, Valid, MissPending
};

class CacheBlock {
public:
    State state;
    int tag;
    vector<string> data;
    CacheBlock() : state(Invalid), tag(0) {
        data.resize(BLOCK_SIZE / WORD_SIZE, "");
    }
};

class CacheSet {
public:
    vector<CacheBlock> blocks;
    CacheSet() {
        blocks.resize(ASSOCIATIVITY);
    }

    int findTag(int tag) {
        for (int i = 0; i < ASSOCIATIVITY; ++i) {
            if (blocks[i].state == Valid && blocks[i].tag == tag)
                return i;
        }
        return -1;
    }

    int getRandomEvictionIndex() {
        return rand() % ASSOCIATIVITY;
    }
};

class Cache {
public:
    int cacheSize;
    int blockSize;
    int associativity;
    int numSets;
    int indexBits;
    int blockOffsetBits;
    int tagBits;
    int totalAccesses;
    int totalHits;
    vector<CacheSet> cacheSets;

    Cache() {
        cacheSize = CACHE_SIZE;
        blockSize = BLOCK_SIZE;
        associativity = ASSOCIATIVITY;
        numSets = cacheSize / (blockSize * associativity);
        blockOffsetBits = log2(blockSize);
        indexBits = log2(numSets);
        tagBits = ADDRESS_SIZE - blockOffsetBits - indexBits;
        cacheSets.resize(numSets);
        totalAccesses = 0;
        totalHits = 0;
    }

    void cache_details() {
        cout << "-------------------------------------------" << endl;
        cout << "       CACHE CONFIGURATION           " << endl;
        cout << "-------------------------------------------" << endl;
        cout << "Cache Type                : " << associativity << "-way Set-Associative Cache" << endl;
        cout << "Cache Size                : " << cacheSize / 1024 << " KB" << endl;
        cout << "Block Size                : " << blockSize << " Bytes" << endl;
        cout << "Associativity (No of Ways): " << associativity << " -ways" << endl;
        cout << "Number of Sets            : " << numSets << endl;
        cout << "Number of Index Bits      : " << indexBits << endl;
        cout << "Number of Block Offset Bits: " << blockOffsetBits << endl;
        cout << "Number of Tag Bits        : " << tagBits << endl;
        cout << "-------------------------------------------" << endl;
    }

    void cache_check_and_process(uint64_t address, char type, string writedata) {
        totalAccesses++;
        int offset = address & ((1 << blockOffsetBits) - 1);
        int index = (address >> blockOffsetBits) & ((1 << indexBits) - 1);
        int tag = (address >> (blockOffsetBits + indexBits)) & ((1 << tagBits) - 1);
        int wordOffsetInBlock = offset / WORD_SIZE;
        CacheSet& cacheSet = cacheSets[index];
        int blockIndex = cacheSet.findTag(tag);
        if (blockIndex != -1 && cacheSet.blocks[blockIndex].state != Invalid) {
            CacheBlock& block = cacheSet.blocks[blockIndex];
            if (block.state == Valid) {
                totalHits++;
                if (type == 'R') {
                    //cout << "Read hit. Data: " << block.data[wordOffsetInBlock] << endl;
                } else if (type == 'W') {
                    block.data[wordOffsetInBlock] = writedata;
                    //cout << "Write hit. Cache updated." << endl;
                }
            } else if (block.state == MissPending) {
                //cout << "Cache miss pending. Waiting for data." << endl;
            }
        } else {
            //cout << "Cache miss. Loading data from memory." << endl;
            int evictionIndex = -1;
            vector<int> invalidIndices;
            for (int i = 0; i < ASSOCIATIVITY; ++i) {
                if (cacheSet.blocks[i].state == Invalid) {
                    invalidIndices.push_back(i);
                }
            }
            if (!invalidIndices.empty()) {
                evictionIndex = invalidIndices[rand() % invalidIndices.size()];
            } else {
                evictionIndex = cacheSet.getRandomEvictionIndex();
            }
            CacheBlock& evictBlock = cacheSet.blocks[evictionIndex];
            evictBlock.state = MissPending;
            evictBlock.tag = tag;
            evictBlock.data = vector<string>(BLOCK_SIZE / WORD_SIZE, (type == 'R') ? "ReadLoadedData" : writedata);
            evictBlock.state = Valid;
        }
    }

    void printHitRate() {
        cout << "------------------------------------" << endl;
        cout << "       CACHE HIT RATE SUMMARY      " << endl;
        cout << "------------------------------------" << endl;
        cout << "Total Accesses    : " << totalAccesses << endl;
        cout << "Total Hits        : " << totalHits << endl;
        cout << "Total Misses      : " << (totalAccesses - totalHits) << endl;
        cout << "Cache Hit Rate    : " << (100.0 * totalHits / totalAccesses) << "%" << endl;
        cout << "------------------------------------" << endl;
    }
};

int main() {
    Cache cache;
    cache.cache_details();

    ifstream inFile("addresses.txt");
    if (!inFile) {
        cout << "Error opening file!" << endl;
        return 1;
    }

    auto start_time = high_resolution_clock::now();
    string line;
    int i = 0;
    while (getline(inFile, line)) {
        uint64_t address = stoull(line); 
        char type = (i % 3 == 0) ? 'W' : 'R'; 
        cache.cache_check_and_process(address, type, "Data " + to_string(i));
        i++;
        auto end_time = high_resolution_clock::now();
        duration<double> time_duration = end_time - start_time;
        if (time_duration.count() >= 15.0) {
            cout << "Stopping after 15 seconds." << endl;
            break;
        }
    }

    cache.printHitRate();
    inFile.close();
    return 0;
}

*/